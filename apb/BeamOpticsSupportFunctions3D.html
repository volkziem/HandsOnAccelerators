<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,IE=9,chrome=1"><meta name="generator" content="MATLAB 2021a"><title>Beam optics support functions 3D (Section 3.4)</title><style type="text/css">.rtcContent { padding: 30px; } .S0 { margin: 2px 10px 9px 4px; padding: 0px; line-height: 21px; min-height: 0px; white-space: pre-wrap; color: rgb(0, 0, 0); font-family: Helvetica, Arial, sans-serif; font-style: normal; font-size: 14px; font-weight: normal; text-align: left;  }
.S1 { margin: 15px 10px 5px 4px; padding: 0px; line-height: 28.8px; min-height: 0px; white-space: pre-wrap; color: rgb(213, 80, 0); font-family: Helvetica, Arial, sans-serif; font-style: normal; font-size: 24px; font-weight: normal; text-align: left;  }
.S2 { margin: 15px 10px 5px 4px; padding: 0px; line-height: 18px; min-height: 0px; white-space: pre-wrap; color: rgb(60, 60, 60); font-family: Helvetica, Arial, sans-serif; font-style: normal; font-size: 17px; font-weight: bold; text-align: left;  }
.S3 { margin: 10px 0px 20px; padding-left: 0px; font-family: Helvetica, Arial, sans-serif; font-size: 14px;  }
.S4 { margin-left: 56px; line-height: 21px; min-height: 0px; text-align: left; white-space: pre-wrap;  }
.CodeBlock { background-color: #F7F7F7; margin: 10px 0 10px 0;}
.S5 { border-left: 1px solid rgb(233, 233, 233); border-right: 1px solid rgb(233, 233, 233); border-top: 1px solid rgb(233, 233, 233); border-bottom: 0px none rgb(0, 0, 0); border-radius: 4px 4px 0px 0px; padding: 6px 45px 0px 13px; line-height: 17.234px; min-height: 18px; white-space: nowrap; color: rgb(0, 0, 0); font-family: Menlo, Monaco, Consolas, "Courier New", monospace; font-size: 14px;  }
.S6 { border-left: 1px solid rgb(233, 233, 233); border-right: 1px solid rgb(233, 233, 233); border-top: 0px none rgb(0, 0, 0); border-bottom: 0px none rgb(0, 0, 0); border-radius: 0px; padding: 0px 45px 0px 13px; line-height: 17.234px; min-height: 18px; white-space: nowrap; color: rgb(0, 0, 0); font-family: Menlo, Monaco, Consolas, "Courier New", monospace; font-size: 14px;  }
.S7 { border-left: 1px solid rgb(233, 233, 233); border-right: 1px solid rgb(233, 233, 233); border-top: 0px none rgb(0, 0, 0); border-bottom: 1px solid rgb(233, 233, 233); border-radius: 0px 0px 4px 4px; padding: 0px 45px 4px 13px; line-height: 17.234px; min-height: 18px; white-space: nowrap; color: rgb(0, 0, 0); font-family: Menlo, Monaco, Consolas, "Courier New", monospace; font-size: 14px;  }
.S8 { margin: 3px 10px 5px 4px; padding: 0px; line-height: 18px; min-height: 0px; white-space: pre-wrap; color: rgb(60, 60, 60); font-family: Helvetica, Arial, sans-serif; font-style: normal; font-size: 17px; font-weight: bold; text-align: left;  }
.S9 { margin: 10px 10px 9px 4px; padding: 0px; line-height: 21px; min-height: 0px; white-space: pre-wrap; color: rgb(0, 0, 0); font-family: Helvetica, Arial, sans-serif; font-style: normal; font-size: 14px; font-weight: normal; text-align: left;  }</style></head><body><div class = rtcContent><div  class = 'S0'><span>Companion software for "Volker Ziemann, </span><span style=' font-style: italic;'>Hands-on Accelerator physics using MATLAB, CRCPress, 2019</span><span>" (https://www.crcpress.com/9781138589940)</span></div><h1  class = 'S1'><span>Beam optics support functions 3D (Section 3.4)</span></h1><div  class = 'S0'><span>Volker Ziemann, 211119</span></div><div  class = 'S0'><span>In this live script we define the functions for the 3D beam optics calculations, such as </span><span style=' font-family: monospace;'>calcmat()</span><span> that a frequently used in other calculations.  All described functions reside in the subdirectory </span><span style=' font-family: monospace;'>3D </span><span>that is contained in the archive </span><span style=' font-family: monospace;'>BeamOpticsSupportFile.zip</span><span>. Any scripts using these function need to include that subirectory with the command  "</span><span style=' font-family: monospace;'>addpath ./3D</span><span>".</span></div><h3  class = 'S2'><span>The function </span><span style=' font-family: monospace;'>calcmat()</span><span> to calculate all transfer matrices</span></h3><div  class = 'S0'><span>The following function receives the </span><span style=' font-family: monospace;'>beamline</span><span> description as input and returns</span></div><ul  class = 'S3'><li  class = 'S4'><span>Racc(3,3,nmat): transfer matrices from the start to the each of each segment, such that R(:,:,end) is the transfer matrix from the start to the end of the beamline.</span></li><li  class = 'S4'><span>spos: position along the beamline after each segment, useful when plotting.</span></li><li  class = 'S4'><span>nmat: number of segments </span></li><li  class = 'S4'><span>nlines: number of lines in the beamline </span></li></ul><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S5'><span style="white-space: pre"><span style="color: rgb(14, 0, 255);">function </span><span >[Racc,spos,nmat,nlines]=calcmat(beamline)</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre"><span >ndim=size(DD(1),1);</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre"><span >nlines=size(beamline,1);      </span><span style="color: rgb(2, 128, 9);">% number of lines in beamline</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre"><span >nmat=sum(beamline(:,2))+1;    </span><span style="color: rgb(2, 128, 9);">% sum over repeat-count in column 2</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre"><span >Racc=zeros(ndim,ndim,nmat);   </span><span style="color: rgb(2, 128, 9);">% matrices from start to element-end</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre"><span >Racc(:,:,1)=eye(ndim);        </span><span style="color: rgb(2, 128, 9);">% initialize first with unit matrix</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre"><span >spos=zeros(nmat,1);           </span><span style="color: rgb(2, 128, 9);">% longitudinal position</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre"><span >ic=1;                         </span><span style="color: rgb(2, 128, 9);">% element counter</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre"><span style="color: rgb(14, 0, 255);">for </span><span >line=1:nlines             </span><span style="color: rgb(2, 128, 9);">% loop over input elements</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre"><span >  </span><span style="color: rgb(14, 0, 255);">for </span><span >seg=1:beamline(line,2)  </span><span style="color: rgb(2, 128, 9);">% loop over repeat-count </span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre"><span >     ic=ic+1;                 </span><span style="color: rgb(2, 128, 9);">% next element          </span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre"><span >     Rcurr=eye(ndim);            </span><span style="color: rgb(2, 128, 9);">% matrix in next element</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre"><span >     </span><span style="color: rgb(14, 0, 255);">switch </span><span >beamline(line,1)  </span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre"><span >       </span><span style="color: rgb(14, 0, 255);">case </span><span >1   </span><span style="color: rgb(2, 128, 9);">% drift</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre"><span >         Rcurr=DD(beamline(line,3));</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre"><span >       </span><span style="color: rgb(14, 0, 255);">case </span><span >2   </span><span style="color: rgb(2, 128, 9);">% thin quadrupole</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre"><span >         Rcurr=Q(beamline(line,4)); </span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre"><span >       </span><span style="color: rgb(14, 0, 255);">case </span><span >4   </span><span style="color: rgb(2, 128, 9);">% sector dipole</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre"><span >         phi=beamline(line,4)*pi/180;  </span><span style="color: rgb(2, 128, 9);">% convert to radians</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre"><span >         rho=beamline(line,3)/phi;</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre"><span >         Rcurr=SB(beamline(line,3),rho);</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre"><span >       </span><span style="color: rgb(14, 0, 255);">case </span><span >5   </span><span style="color: rgb(2, 128, 9);">% thick quadrupole</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre"><span >         Rcurr=QQ(beamline(line,3),beamline(line,4));   </span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre"><span >       </span><span style="color: rgb(14, 0, 255);">otherwise</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre"><span >         disp(</span><span style="color: rgb(170, 4, 249);">'unsupported code'</span><span >)</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre"><span >     </span><span style="color: rgb(14, 0, 255);">end</span><span >		  </span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre"><span >     Racc(:,:,ic)=Rcurr*Racc(:,:,ic-1);    </span><span style="color: rgb(2, 128, 9);">% concatenate </span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre"><span >     spos(ic)=spos(ic-1)+beamline(line,3); </span><span style="color: rgb(2, 128, 9);">% position of element   </span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre"><span >  </span><span style="color: rgb(14, 0, 255);">end</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre"><span style="color: rgb(14, 0, 255);">end</span></span></div></div><div class="inlineWrapper"><div  class = 'S7'><span style="white-space: pre"><span style="color: rgb(14, 0, 255);">end</span></span></div></div></div><h3  class = 'S8'><span>Transfer matrix for a drift space </span><span style=' font-family: monospace;'>DD(L)</span></h3><div  class = 'S0'><span>The function </span><span style=' font-family: monospace;'>DD()</span><span> receives the length</span><span style=' font-family: monospace;'> L </span><span>of a drift space and resturns the 3x3 transfer matrix</span><span style=' font-family: monospace;'> out</span><span> for a drift space.</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S5'><span style="white-space: pre"><span style="color: rgb(14, 0, 255);">function </span><span >out=DD(L)</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre"><span >out=eye(3);</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre"><span >out(1,2)=L;</span></span></div></div><div class="inlineWrapper"><div  class = 'S7'><span style="white-space: pre"><span style="color: rgb(14, 0, 255);">end</span></span></div></div></div><h3  class = 'S2'><span>Transfer matrix for a thin-lens quadrupole </span><span style=' font-family: monospace;'>Q(F)</span></h3><div  class = 'S0'><span>The function </span><span style=' font-family: monospace;'>Q()</span><span> receives the focal length</span><span style=' font-family: monospace;'> F </span><span>as input and returns the 3x3 transfer matrix</span><span style=' font-family: monospace;'> out</span><span> for a thin-lens quadrupole.</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S5'><span style="white-space: pre"><span style="color: rgb(14, 0, 255);">function </span><span >out=Q(F)</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre"><span >out=eye(3);</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre"><span style="color: rgb(14, 0, 255);">if </span><span >abs(F)&lt;1e-8 </span><span style="color: rgb(14, 0, 255);">return</span><span >; </span><span style="color: rgb(14, 0, 255);">end</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre"><span >out(2,1)=-1/F;</span></span></div></div><div class="inlineWrapper"><div  class = 'S7'><span style="white-space: pre"><span style="color: rgb(14, 0, 255);">end</span></span></div></div></div><h3  class = 'S2'><span>Transfer matrix for a thick quadrupole </span><span style=' font-family: monospace;'>Q(F)</span></h3><div  class = 'S0'><span>The function </span><span style=' font-family: monospace;'>QQ()</span><span> receives the length</span><span style=' font-family: monospace;'> L </span><span>and </span><span style=' font-family: monospace;'>k1 </span><span>as input and returns the 3x3 transfer matrix</span><span style=' font-family: monospace;'> out</span><span> for a thick quadrupole.</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S5'><span style="white-space: pre"><span style="color: rgb(14, 0, 255);">function </span><span >out=QQ(L,k1)</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre"><span >ksq=sqrt(abs(k1));</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre"><span >out=eye(3);</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre"><span style="color: rgb(14, 0, 255);">if </span><span >abs(k1) &lt; 1e-6</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre"><span >    out(1,2)=L;</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre"><span style="color: rgb(14, 0, 255);">elseif </span><span >k1&gt;0</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre"><span >    out(1:2,1:2)=[cos(ksq*L),sin(ksq*L)/ksq;-ksq*sin(ksq*L),cos(ksq*L)];    </span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre"><span style="color: rgb(14, 0, 255);">else</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre"><span >    out(1:2,1:2)=[cosh(ksq*L),sinh(ksq*L)/ksq;ksq*sinh(ksq*L),cosh(ksq*L)];</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre"><span style="color: rgb(14, 0, 255);">end</span></span></div></div><div class="inlineWrapper"><div  class = 'S7'><span style="white-space: pre"><span style="color: rgb(14, 0, 255);">end</span></span></div></div></div><h3  class = 'S2'><span>Transfer matrix for a sector dipole </span><span style=' font-family: monospace;'>SB(L,rho)</span></h3><div  class = 'S0'><span>The function </span><span style=' font-family: monospace;'>SB()</span><span> receives the length</span><span style=' font-family: monospace;'> L</span><span> and bending radius </span><span style=' font-family: monospace;'>rho</span><span> of a horizontally deflecting sector dipole magnet and returns its 3x3 transfer matrix</span><span style=' font-family: monospace;'> out</span><span>.</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S5'><span style="white-space: pre"><span style="color: rgb(14, 0, 255);">function </span><span >out=SB(L,rho)</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre"><span >phi=L/rho;</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre"><span >out=eye(3);</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre"><span style="color: rgb(14, 0, 255);">if </span><span >abs(phi)&lt;1e-8</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre"><span >  out(1,2)=L;</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre"><span style="color: rgb(14, 0, 255);">else</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre"><span >  out(1:2,1:3)=[cos(phi),rho*sin(phi),rho*(1-cos(phi)); </span><span style="color: rgb(14, 0, 255);">...</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre"><span >                -sin(phi)/rho,cos(phi),sin(phi)];</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre"><span style="color: rgb(14, 0, 255);">end</span></span></div></div><div class="inlineWrapper"><div  class = 'S7'><span style="white-space: pre"><span style="color: rgb(14, 0, 255);">end</span></span></div></div></div><h3  class = 'S2'><span>plot_betas()</span></h3><div  class = 'S0'><span>The function </span><span style=' font-family: monospace;'>plot_betas()</span><span> receives the </span><span style=' font-family: monospace;'>beamline</span><span> description and the initial 3x3 beam matrix </span><span style=' font-family: monospace;'>sigma0</span><span> as input an produces a plot of the beta function. This function assumes that the emittance of sigma0 is 1, or </span><span texencoding="\det\sigma_0=1" style="vertical-align:-6px"><img src="data:image/png;base64,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" width="62.5" height="20" /></span><span>, such that </span><span texencoding="\sigma_{11}=\beta" style="vertical-align:-6px"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAF8AAAAoCAYAAACYayaMAAAEiUlEQVRoQ+3ad+h9cxzH8cfPJpG9hWxZyZ4Zf1lF9ohIKJQthIjI/sOMjGzKSuIPo6zIKDvjD2VlZO/Ri8/9uZ3uvd9z7/feTj+/867vH99zPp/35/N5nvd5r3NnaKUxAjMaW7ldWAu/QSNo4bfwGyTQ4NKt5bfwGyQwuaW3xjZYHp/iHrzZvVxr+eOHvxJuxzO4Hl/jauyJo3BNZ8kW/njhr4rncDEu7FK9Bt7Gt1gUf+ReC3988OfGa/gZG+GvLtXz48fy/1L4vIU/PvDRdAyuxG54qKJ6reLvP8ZyrdsZL/iF8H7xJMvgt4r6U3EBTsFFLfzxwj+pQL0Zh1RUL4w38AF26H4ww/r8Bcprk6BRlTztl8d7pllG2yvYAAfjVsyHecvfjQX4AV1+/5+D1YG/YEmR9imBpB+RJ7D9LINrfBvt+PNoXAGx9BjhPPgTLyDgP6wuORX8XUpeOjNIDNjz2ThnfGeqpWlX3F1r5OBBsdgUQaPIGTgX72DNYtDrlYwmsaCTAW2F17sXGAT/iFIczIGfSsC4s0T1FbFHebKjbHhcc3bH/WNQti/uGlHP00g1m0Lq6B46nsemeBDZ70zpB38nPIqA/wqxsGfLrLxO7+EpHIZfR9z0/2FaXHL4JMffC/f2ONSrWB+fYNmp4CeoBm5SpviszfBiRenlOA434PD/A8URzxC3nJw+BdUS+LKiZ058XwJwKtzEh4GW30mbMih9iPQjqpJrV+F3xK/FLVUlr1j84cZTHKzuuBH5THTaFTgWse4Ne6y0Gt4t1+/A/lPBT4BIwPgOq+CLHkpPKP2L3EowTuXWkS1KypWY8QtSWveSuuMmSm+ayt8qQfYSnNhDV7xDvERkPyRmzpSqz1+k+LAMSBaR9LKX3IKDSkRfukcfI2/CS1hnAPw8lDrjBvFpMttJq/ijsrmd8Uhlo3OVqjfJSVrJ61YTlCr8wOqkQ8fjsh4nT5BJzro4zsfpfegk70+86Gf5nWl1x/Vapsls51CkgIrrjdHGt3dL0tdUvJEYycPVA1ThL4nPyqADcVuPE3f6FOllJIr/0CD8QW/FpO+lZx9Xkixwy8piKbRS9a6M83Bmr830SjVj1fkgEL9+aWVS8tXH8Q22K69Vv0PWtei64yYNcxj94ZavUzHWKtyknfcVa4/xxj13t5dnrtMLfl6RB0rzP7ATeCOp0HI9xchp5QEM2nBdqHXHDQNn0mPTx4llR7qNNHEg6XfaLCf3cdsD4efm5jgLiyERPQ8pHwmu65Hzz46W30nH4wGSQsbfp4BaHU+Wz4edFLOvIUzV25mOBdW16LrjprOXcc99DOkCpB+096jKW/jDk0u7OC2FZHHJeG4aXsW/M1r4w5PbsSQdCaJxNQm8I0kLf3hsqWZTA6Xftcnw0/+bMUn4aVOsXb7mpEHXT+qOm845xzU3aWSq2vwC4UhcOx3Fk4C/bel0pkiLpMpLdVdtt9YdN53zjXtu+vadhmJ+jdZJw0daZxLwR9rI7Diphd/gU2/ht/AbJNDg0q3lt/AbJNDg0q3lNwj/b13+2in+i3siAAAAAElFTkSuQmCC" width="47.5" height="20" /></span><span> is the beta function. It then uses Equation 3.43 to propagate </span><span style="font-family: STIXGeneral, STIXGeneral-webfont, serif; font-style: italic; font-weight: normal; color: rgb(0, 0, 0);">Ïƒ</span><span>.</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S5'><span style="white-space: pre"><span style="color: rgb(14, 0, 255);">function </span><span >plot_betas(beamline,sigma0)</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre"><span >[Racc,spos]=calcmat(beamline);</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre"><span >betax=zeros(1,length(spos)); betay=betax;</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre"><span style="color: rgb(14, 0, 255);">for </span><span >k=1:length(spos)</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre"><span >   sigma=Racc(:,:,k)*sigma0*Racc(:,:,k)';</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre"><span >   betax(k)=sigma(1,1); </span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre"><span style="color: rgb(14, 0, 255);">end</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre"><span >plot(spos,betax,</span><span style="color: rgb(170, 4, 249);">'k'</span><span >);</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre"><span >xlabel(</span><span style="color: rgb(170, 4, 249);">' s[m]'</span><span >); ylabel(</span><span style="color: rgb(170, 4, 249);">'\beta_x [m]'</span><span >)</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre"><span >axis([0, max(spos), 0, 1.05*max(betax)])</span></span></div></div><div class="inlineWrapper"><div  class = 'S7'><span style="white-space: pre"><span style="color: rgb(14, 0, 255);">end</span></span></div></div></div><h3  class = 'S2'><span>drawmag()</span></h3><div  class = 'S0'><span>The function</span><span style=' font-family: monospace;'> drawmag()</span><span> receives the beamline description and the vertical position </span><span style=' font-family: monospace;'>vpos</span><span> and </span><span style=' font-family: monospace;'>height</span><span> of the magnets on the plot as input and produces a graphical rendition of the quadrupoles and dipoles on a plot.</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S5'><span style="white-space: pre"><span style="color: rgb(14, 0, 255);">function </span><span >drawmag(beamline,vpos,height)</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre"><span >hold </span><span style="color: rgb(170, 4, 249);">on</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre"><span style="color: rgb(2, 128, 9);">% legend('AutoUpdate','off')  % avoids an extra entry for the magnet drawings</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre"><span >nlines=size(beamline,1);</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre"><span >nmat=sum(beamline(:,2))+1;</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre"><span >spos=zeros(nmat,1);</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre"><span >ic=1;</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre"><span style="color: rgb(14, 0, 255);">for </span><span >line=1:nlines </span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre"><span >  </span><span style="color: rgb(14, 0, 255);">for </span><span >seg=1:beamline(line,2)</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre"><span >    ic=ic+1;</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre"><span >    </span><span style="color: rgb(14, 0, 255);">switch </span><span >beamline(line,1)</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre"><span >        </span><span style="color: rgb(14, 0, 255);">case </span><span >2</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre"><span >            dv=0.15*height*sign(beamline(line,4));</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre"><span >            rectangle(</span><span style="color: rgb(170, 4, 249);">'Position'</span><span >,[spos(ic-1),vpos+dv,0.1,height])</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre"><span >        </span><span style="color: rgb(14, 0, 255);">case </span><span >4</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre"><span >            L=beamline(line,3);</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre"><span >            rectangle(</span><span style="color: rgb(170, 4, 249);">'Position'</span><span >, </span><span style="color: rgb(14, 0, 255);">...</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre"><span >                [spos(ic-1),vpos+0.25*height,L,0.5*height])</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre"><span >        </span><span style="color: rgb(14, 0, 255);">case </span><span >5</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre"><span >            L=beamline(line,3);</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre"><span >            dv=0.15*height*sign(beamline(line,4));</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre"><span >            rectangle(</span><span style="color: rgb(170, 4, 249);">'Position'</span><span >,[spos(ic-1),vpos+dv,L,height])</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre"><span >    </span><span style="color: rgb(14, 0, 255);">end</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre"><span >    spos(ic)=spos(ic-1)+beamline(line,3);</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre"><span >  </span><span style="color: rgb(14, 0, 255);">end</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre"><span style="color: rgb(14, 0, 255);">end</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre"><span >plot([spos(1),spos(end)],[vpos+0.5*height,vpos+0.5*height],</span><span style="color: rgb(170, 4, 249);">'k:'</span><span >);</span></span></div></div><div class="inlineWrapper"><div  class = 'S7'><span style="white-space: pre"><span style="color: rgb(14, 0, 255);">end</span></span></div></div></div><h3  class = 'S2'><span>periodic_dispersion()</span></h3><div  class = 'S0'><span>The function </span><span style=' font-family: monospace;'>periodic_dispersion()</span><span> receives a 3x3 transfer matrix </span><span style=' font-family: monospace;'>Rend</span><span> as input and returns the 3x1 initial dispersion vector </span><span style=' font-family: monospace;'>D0</span><span> that repeats after applying </span><span style=' font-family: monospace;'>Rend</span><span> to it. </span><span style=' font-family: monospace;'>D0</span><span> is calculated from Equation 3.94.</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S5'><span style="white-space: pre"><span style="color: rgb(14, 0, 255);">function </span><span >D0=periodic_dispersion(Rend)</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre"><span >D=(eye(2)-Rend(1:2,1:2))\Rend(1:2,3); </span><span style="color: rgb(2, 128, 9);">% eq. 3.94</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre"><span >D0=[D;1];</span></span></div></div><div class="inlineWrapper"><div  class = 'S7'><span style="white-space: pre"><span style="color: rgb(14, 0, 255);">end</span></span></div></div></div><h3  class = 'S2'><span>calculate_dispersion()</span></h3><div  class = 'S0'><span>The function </span><span style=' font-family: monospace;'>calculate_dispersion()</span><span> receives the </span><span style=' font-family: monospace;'>beamline</span><span> description and the initial dispersion </span><span style=' font-family: monospace;'>D0</span><span> as input and returns an array </span><span style=' font-family: monospace;'>D</span><span> that contains the dispersion along the beam line as well as the positions</span><span style=' font-family: monospace;'> spos</span><span>.</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S5'><span style="white-space: pre"><span style="color: rgb(14, 0, 255);">function </span><span >[D,spos]=calculate_dispersion(beamline,D0)</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre"><span >[Racc,spos]=calcmat(beamline);</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre"><span >D=zeros(length(spos),1);</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre"><span style="color: rgb(14, 0, 255);">for </span><span >k=1:length(spos)</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre"><span >   D(k)=Racc(1,:,k)*D0;</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre"><span style="color: rgb(14, 0, 255);">end</span></span></div></div><div class="inlineWrapper"><div  class = 'S7'><span style="white-space: pre"><span style="color: rgb(14, 0, 255);">end</span></span></div></div></div><div  class = 'S9'></div>
<br>
<!-- 
##### SOURCE BEGIN #####
function [Racc,spos,nmat,nlines]=calcmat(beamline)
%  CALCMAT Companion software for "Volker Ziemann, _Hands-on Accelerator physics using 
% MATLAB, CRCPress, 2019_" (https://www.crcpress.com/9781138589940)
%% Beam optics support functions 3D (Section 3.4)
% Volker Ziemann, 211119
% 
% In this live script we define the functions for the 3D beam optics calculations, 
% such as |calcmat()| that a frequently used in other calculations.  All described 
% functions reside in the subdirectory |3D| that is contained in the archive |BeamOpticsSupportFile.zip|. 
% Any scripts using these function need to include that subirectory with the command  
% "|addpath ./3D|".
% The function |calcmat()| to calculate all transfer matrices
% The following function receives the |beamline| description as input and returns
%% 
% * Racc(3,3,nmat): transfer matrices from the start to the each of each segment, 
% such that R(:,:,end) is the transfer matrix from the start to the end of the 
% beamline.
% * spos: position along the beamline after each segment, useful when plotting.
% * nmat: number of segments 
% * nlines: number of lines in the beamline 
ndim=size(DD(1),1);
nlines=size(beamline,1);      % number of lines in beamline
nmat=sum(beamline(:,2))+1;    % sum over repeat-count in column 2
Racc=zeros(ndim,ndim,nmat);   % matrices from start to element-end
Racc(:,:,1)=eye(ndim);        % initialize first with unit matrix
spos=zeros(nmat,1);           % longitudinal position
ic=1;                         % element counter
for line=1:nlines             % loop over input elements
  for seg=1:beamline(line,2)  % loop over repeat-count 
     ic=ic+1;                 % next element          
     Rcurr=eye(ndim);            % matrix in next element
     switch beamline(line,1)  
       case 1   % drift
         Rcurr=DD(beamline(line,3));
       case 2   % thin quadrupole
         Rcurr=Q(beamline(line,4)); 
       case 4   % sector dipole
         phi=beamline(line,4)*pi/180;  % convert to radians
         rho=beamline(line,3)/phi;
         Rcurr=SB(beamline(line,3),rho);
       case 5   % thick quadrupole
         Rcurr=QQ(beamline(line,3),beamline(line,4));   
       otherwise
         disp('unsupported code')
     end		  
     Racc(:,:,ic)=Rcurr*Racc(:,:,ic-1);    % concatenate 
     spos(ic)=spos(ic-1)+beamline(line,3); % position of element   
  end
end
end
% Transfer matrix for a drift space |DD(L)|
% The function |DD()| receives the length |L| of a drift space and resturns 
% the 3x3 transfer matrix |out| for a drift space.
function out=DD(L)
out=eye(3);
out(1,2)=L;
end
% Transfer matrix for a thin-lens quadrupole |Q(F)|
% The function |Q()| receives the focal length |F| as input and returns the 
% 3x3 transfer matrix |out| for a thin-lens quadrupole.
function out=Q(F)
out=eye(3);
if abs(F)<1e-8 return; end
out(2,1)=-1/F;
end
% Transfer matrix for a thick quadrupole |Q(F)|
% The function |QQ()| receives the length |L| and |k1| as input and returns 
% the 3x3 transfer matrix |out| for a thick quadrupole.
function out=QQ(L,k1)
ksq=sqrt(abs(k1));
out=eye(3);
if abs(k1) < 1e-6
    out(1,2)=L;
elseif k1>0
    out(1:2,1:2)=[cos(ksq*L),sin(ksq*L)/ksq;-ksq*sin(ksq*L),cos(ksq*L)];    
else
    out(1:2,1:2)=[cosh(ksq*L),sinh(ksq*L)/ksq;ksq*sinh(ksq*L),cosh(ksq*L)];
end
end
% Transfer matrix for a sector dipole |SB(L,rho)|
% The function |SB()| receives the length |L| and bending radius |rho| of a 
% horizontally deflecting sector dipole magnet and returns its 3x3 transfer matrix 
% |out|.
function out=SB(L,rho)
phi=L/rho;
out=eye(3);
if abs(phi)<1e-8
  out(1,2)=L;
else
  out(1:2,1:3)=[cos(phi),rho*sin(phi),rho*(1-cos(phi)); ...
                -sin(phi)/rho,cos(phi),sin(phi)];
end
end
% plot_betas()
% The function |plot_betas()| receives the |beamline| description and the initial 
% 3x3 beam matrix |sigma0| as input an produces a plot of the beta function. This 
% function assumes that the emittance of sigma0 is 1, or $\det\sigma_0=1$, such 
% that $\sigma_{11}=\beta$ is the beta function. It then uses Equation 3.43 to 
% propagate $\sigma$.
function plot_betas(beamline,sigma0)
[Racc,spos]=calcmat(beamline);
betax=zeros(1,length(spos)); betay=betax;
for k=1:length(spos)
   sigma=Racc(:,:,k)*sigma0*Racc(:,:,k)';
   betax(k)=sigma(1,1); 
end
plot(spos,betax,'k');
xlabel(' s[m]'); ylabel('\beta_x [m]')
axis([0, max(spos), 0, 1.05*max(betax)])
end
% drawmag()
% The function |drawmag()| receives the beamline description and the vertical 
% position |vpos| and |height| of the magnets on the plot as input and produces 
% a graphical rendition of the quadrupoles and dipoles on a plot.
function drawmag(beamline,vpos,height)
hold on
% legend('AutoUpdate','off')  % avoids an extra entry for the magnet drawings
nlines=size(beamline,1);
nmat=sum(beamline(:,2))+1;
spos=zeros(nmat,1);
ic=1;
for line=1:nlines 
  for seg=1:beamline(line,2)
    ic=ic+1;
    switch beamline(line,1)
        case 2
            dv=0.15*height*sign(beamline(line,4));
            rectangle('Position',[spos(ic-1),vpos+dv,0.1,height])
        case 4
            L=beamline(line,3);
            rectangle('Position', ...
                [spos(ic-1),vpos+0.25*height,L,0.5*height])
        case 5
            L=beamline(line,3);
            dv=0.15*height*sign(beamline(line,4));
            rectangle('Position',[spos(ic-1),vpos+dv,L,height])
    end
    spos(ic)=spos(ic-1)+beamline(line,3);
  end
end
plot([spos(1),spos(end)],[vpos+0.5*height,vpos+0.5*height],'k:');
end
% periodic_dispersion()
% The function |periodic_dispersion()| receives a 3x3 transfer matrix |Rend| 
% as input and returns the 3x1 initial dispersion vector |D0| that repeats after 
% applying |Rend| to it. |D0| is calculated from Equation 3.94.
function D0=periodic_dispersion(Rend)
D=(eye(2)-Rend(1:2,1:2))\Rend(1:2,3); % eq. 3.94
D0=[D;1];
end
% calculate_dispersion()
% The function |calculate_dispersion()| receives the |beamline| description 
% and the initial dispersion |D0| as input and returns an array |D| that contains 
% the dispersion along the beam line as well as the positions |spos|.
function [D,spos]=calculate_dispersion(beamline,D0)
[Racc,spos]=calcmat(beamline);
D=zeros(length(spos),1);
for k=1:length(spos)
   D(k)=Racc(1,:,k)*D0;
end
end
%% 
%
##### SOURCE END #####
-->
</div></body></html>